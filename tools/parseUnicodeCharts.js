/* eslint-env node */
const fetch = require('node-fetch');
const jsdom = require('jsdom');
const fs = require('fs-extra');
const path = require('path');

// For `localize` `true`, need to provide strings for all
//  possible; could auto-add to locale files if missing
const localize = true;

const {JSDOM} = jsdom;

(async () => {
let text;
const lastScriptNamesFile = path.join(__dirname, '../browser_action/unicode/lastScriptNames.json');
const chartsURL = 'https://www.unicode.org/charts/';
const chartsFile = path.join(__dirname, 'unicode-charts.html');
if (process.argv[2] === 'retrieve') {
    const resp = await fetch(chartsURL);
    text = await resp.text();
    console.log('retrieved', text);
    await fs.writeFile(chartsFile, text);
    console.log('saved file');
} else {
    text = await fs.readFile(chartsFile, 'utf-8');
}

const doc = new JSDOM(text).window.document;
const scriptMaps = [...doc.querySelectorAll('table.map')];

const uniqueTextPlaceholder = localize ? '___placeholder___' : ''; // We know it is not present inside Unicode script names!

const cleanupText = (txt) => {
    return txt.trim()
        .replace(/(\s)\s+/, '$1')
        .replace(/\s*\((?:ASCII|Odia)\)$/, '')
        .replace(/\s\((?:\d\.?\d*)MB\)$/, ''); // Remove MB size
};

const jamilih = scriptMaps.map((scriptMap) => {
    const majorHeading = cleanupText(scriptMap.previousElementSibling.textContent);
    // const scriptGroups = [...scriptMap.querySelectorAll('table td p')];

    const scriptGroups = [...scriptMap.querySelectorAll('table td p.sg')];
    // sg, mb, pb/sb
    let lastChildren;
    return ['li', [
        majorHeading,
        ['ul', scriptGroups.map((scriptGroup) => {
            return ['li', [
                ['b', [
                    uniqueTextPlaceholder + cleanupText(scriptGroup.textContent)
                ]],
                (() => {
                    const lists = [];
                    do {
                        const a = scriptGroup.querySelector('a');
                        const title = a && a.title;
                        if (scriptGroup.matches('.mb')) {
                            const children = [uniqueTextPlaceholder + cleanupText(scriptGroup.textContent)];
                            lastChildren = children;
                            lists.push(
                                ['li', {title}, children]
                            );
                        } else if (scriptGroup.matches('.pb,.sb')) {
                            const children = [
                                ['i', [
                                    uniqueTextPlaceholder + cleanupText(scriptGroup.textContent)
                                ]]
                            ];
                            if (!lastChildren) { // A few rare cases to handle, e.g., "Other"
                                lists.push(
                                    ['li', {title}, children]
                                );
                            } else {
                                if (!lastChildren[1]) {
                                    lastChildren[1] = ['ul', []];
                                }
                                lastChildren[1][1].push(
                                    ['li', {title}, children]
                                );
                            }
                        }
                        scriptGroup = scriptGroup.nextElementSibling;
                    } while (scriptGroup && !scriptGroup.matches('p.sg'));
                    lastChildren = null;
                    if (!lists.length) { // Just be safe
                        return '';
                    }
                    return ['ul', lists];
                })()
            ]];
        })]
    ]];
});
// console.log('m', majorHeading, scriptGroups);

async function saveLocalesWithoutDupes (localeFiles, localeFileContents) {
    return Promise.all(
        localeFiles.map((localeFile, i) => {
            return fs.writeFile(localeFile, JSON.stringify(localeFileContents[i], null, 4) + '\n');
        })
    );
}
async function deleteUnusedScriptNames (newScriptNames, localeFileContents) {
    const {lastScriptNames} = JSON.parse(await fs.readFile(lastScriptNamesFile, 'utf-8'));
    lastScriptNames.forEach((lastScriptName) => {
        if (!newScriptNames.includes(lastScriptName)) {
            localeFileContents.forEach((lfc) => {
                delete lfc[lastScriptName];
            });
        }
    });
}

// We only actually need the ESLint `indent` rule for the localized version, but add anyway
await fs.writeFile(
    'browser_action/unicode/unicode-scripts.js',
    `/* eslint-disable comma-spacing, quotes, indent */
// Do not edit this file; this is an auto-generated file used to
//   build a hierarchy of script names. It is built by
//   \`parseUnicodeCharts.js\` using ${chartsURL}.
export default function (_) {
    return ` + (localize
        ? await (async () => {
            const localesDir = '_locales';
            const dirs = (await fs.readdir(localesDir)).filter((f) => !f.includes('.'));
            const localeFiles = dirs.map((dir) => path.join(localesDir, dir, 'messages.json'));
            const localeFileContents = (await Promise.all(localeFiles.map((localeFile) => {
                return fs.readFile(localeFile, 'utf-8');
            }))).map((fileContents) => {
                return JSON.parse(fileContents);
            });

            const newScriptNames = [];
            const ret = JSON.stringify(['ul', jamilih], null, 4).replace(
                new RegExp(
                    '^(\\s*)"' + uniqueTextPlaceholder + '(.*)"(,)?$',
                    'gm'
                ),
                (_, initialWS, key, possibleComma = '') => {
                    const chromeSafeLocaleKey = key.replace(/\\n/g, '').replace(/\s\s*/g, ' ') // Getting some extra WS
                        .replace(/\W/g, '_');
                    newScriptNames.push(chromeSafeLocaleKey);
                    // Insert `chromeSafeLocaleKey` if not present;
                    //   Todo: Hard-code-test each locale to make sure no other
                    //          l10n errors for missing keys, script or otherwise
                    localeFileContents.forEach((lfc, i) => {
                        /*
                        // Works
                        localeFileContents.forEach((lfc2, j) => {
                            if (i === j) {
                                return;
                            }
                            Object.entries(lfc).forEach(([key, val]) => {
                                if (!(key in lfc2)) {
                                    console.log(`key, ${key}, not present in ${localeFiles[j]}`);
                                }
                            });
                        });
                        */
                        if (lfc.langCode.message !== 'hu-HU') {
                            // return;
                        }
                        if (!(chromeSafeLocaleKey in lfc)) {
                            lfc[chromeSafeLocaleKey] = {
                                message: key
                            };
                            // console.log(1, chromeSafeLocaleKey, key);
                            // fs.writeFile(localeFiles[i], JSON.stringify(lfc, null, 4));
                        }
                    });
                    /*
                    // Find change in *values*
                    if (lfc[chromeSafeLocaleKey] && lfc[chromeSafeLocaleKey].message !== key) {
                        console.log(key, lfc[chromeSafeLocaleKey].message);
                    }
                    */
                    return `${initialWS}_("${chromeSafeLocaleKey}")${possibleComma}`;
                }
            );
            await deleteUnusedScriptNames(newScriptNames, localeFileContents);
            await saveLocalesWithoutDupes(localeFiles, localeFileContents);

            await fs.writeFile(lastScriptNamesFile, `
{
    "$comment": "Do not edit this file; this is an auto-generated file used to track script names, some of which may end up needing to be deleted from locale files if no longer in use",
    "lastScriptNames": ${JSON.stringify(newScriptNames)}
}
`);
            return ret;
        })()
        : JSON.stringify(['ul', jamilih], null, 4)
    ) +
    `;
}
`);
})();
